const EventEmitter = require('events');
const {createConnection} = require('net');

class Queue {
  constructor() {
    this._head = null;
    this._tail = null;
    this._length = 0;
  }

  dequeue() {
    const node = this._head;
    if (node) {
      this._head = node.next;
      this._length--;
      if (this._head === null) {
        this._tail = null;
      }
      return node.value;
    } else {
      return null;
    }
  }

  enqueue(item) {
    const node = {
      next: null,
      value: item,
    };
    if (this._tail) {
      this._tail.next = node;
      this._tail = node;
    } else {
      this._head = node;
      this._tail = node;
    }
    this._length++;
  }

  isEmpty() {
    return this._length === 0;
  }

  get length() {
    return this._length;
  }
}

class RedisClient extends EventEmitter {
  static STATE = {
    NEW: 0, // Constructed but not yet ready.
    BUSY: 1, // Waiting for a reply.
    READY: 2, // Ready for a command.
  };

  constructor() {
    super();

    this._queue = new Queue();
    this._buffer = '';
    this._state = RedisClient.STATE.NEW;

    this.socket = createConnection({
      host: '127.0.0.1',
      port: 6379,
    })
      .on('close', (hadError) => this._onClose(hadError))
      .on('connect', () => this._onConnect())
      .on('data', (data) => this._onData(data))
      .on('error', (error) => this._onError(error))
      .on('ready', () => this._onReady())
      .on('timeout', () => this._onTimeout())
      .setNoDelay();
    // TODO: implement retry logic

    // Switch to RESP3 Protocol before any caller enqueues a command.
    this.command('HELLO', 3); // TODO: .catch() error-handling (add ERROR state)
  }

  close() {
    this.socket.end();
  }

  command(name, ...args) {
    return new Promise((resolve, reject) => {
      this._queue.enqueue(() => {
        this._state = RedisClient.STATE.BUSY;
        this.once('response', (result) => {
          // TODO: handle error case (eg. check `result` and call `reject`)
          resolve(result);
          this._runQueue();
        });
        this.socket.write(this._encodeCommand(name, ...args));
      });
      this._runQueue();
    });
  }

  multi(commands) {
    return new Promise((resolve, reject) => {
      this._queue.enqueue(() => {
        this._state = RedisClient.STATE.BUSY;
        this.once('response', (result) => {
          // TODO: handle error case (eg. check `result` and call `reject`)
          // console.log(result);
          if (
            !Array.isArray(result) ||
            result.length !== commands.length + 2 ||
            result[0] !== 'OK' ||
            !result
              .slice(1, commands.length + 1)
              .every((item) => item === 'QUEUED') ||
            !Array.isArray(result[result.length - 1])
          ) {
            reject(new Error('Invalid response'));
          } else {
            resolve(result[result.length - 1]);
          }
          this._runQueue();
        });
        const pipelinedCommands = [['MULTI'], ...commands, ['EXEC']]
          .map((command) => {
            return this._encodeCommand(...command);
          })
          .join('');
        this.socket.write(pipelinedCommands);
      });
      this._runQueue();
    });
  }

  _encodeCommand(name, ...args) {
    let command = '*' + (args.length + 1) + '\r\n';
    command += [name, ...args]
      .map((value) => {
        const string = value.toString();
        return '$' + string.length + '\r\n' + string + '\r\n';
      })
      .join('');
    return command;
  }

  _runQueue() {
    if (this._state === RedisClient.STATE.READY && !this._queue.isEmpty()) {
      const callback = this._queue.dequeue();
      callback();
    }
  }

  _onClose(hadError) {
    // TODO
  }

  _onConnect() {
    // TODO... maybe nothing...
  }

  _onData(data) {
    this._buffer += data.toString();

    if (!this._buffer.endsWith('\r\n')) {
      // Don't bother trying to parse result until we have at least a full line.
      return;
    }

    // In this app, we expect all responses to be small enough to fit in a
    // single `data` payload. So, in the event that we ever see what looks to be
    // a partial payload, we give up and allow it to be reprocessed on the next
    // call. This _would_ be inefficient, if it ever happened...
    const responses = [];
    const parser = new ResponseParser(this._buffer);
    while (true) {
      try {
        // BUG: this is flaky; if I run a lot of `multi` batches I don't always
        // get the same results back.
        const result = parser.parse();
        if (result === undefined) {
          break; // We got to the end of the input; no more responses.
        } else {
          responses.push(result);
        }
      } catch (error) {
        // Will try again on next call.
        break;
      }
    }
    this._buffer = '';
    this._state = RedisClient.STATE.READY;

    if (responses.length === 1) {
      // Hackily assume that a single response means we're not pipelining.
      this.emit('response', responses[0]);
    } else {
      this.emit('response', responses);
    }
  }

  _onError(error) {
    // TODO
  }

  _onReady() {
    this._state = RedisClient.STATE.READY;
    this._runQueue();
  }

  _onTimeout() {
    // TODO
  }

  get state() {
    return this._state;
  }
}

class RedisConnectionPool {
  constructor() {
    this._clients = [];
  }

  get client() {
    const clients = this._clients;
    return {
      command(name, ...args) {
        const client = clients.pop() || new RedisClient();
        return client.command(name, ...args).then((result) => {
          clients.push(client);
          return result;
        });
      },
      multi(commands) {
        const client = clients.pop() || new RedisClient();
        return client.multi(commands).then((result) => {
          clients.push(client);
          return result;
        });
      },

      // Commands.

      // See: https://redis.io/commands/get
      get(key) {
        return this.command('GET', key);
      },

      // See: https://redis.io/commands/set
      set(key, value) {
        return this.command('SET', key, value);
      },

      // See: https://redis.io/commands/zadd
      zadd(key, score, member) {
        return this.command('ZADD', key, score, member);
      },

      // See: https://redis.io/commands/zcard
      zcard(key) {
        return this.command('ZCARD', key);
      },

      // See: https://redis.io/commands/zincrby
      zincrby(key, increment, member) {
        return this.command('ZINCRBY', key, increment, member);
      },

      // See: https://redis.io/commands/zrem
      zrem(key, member) {
        return this.command('ZREM', key, member);
      },

      // See: https://redis.io/commands/zremrangebyscore
      zremrangebyscore(key, min, max) {
        return this.command('ZREMRANGEBYSCORE', key, min, max);
      },

      // ZREVRANGE is deprecated, so we translate it to ZRANGE.
      // See: https://redis.io/commands/zrevrange
      zrevrange(key, start, stop) {
        return this.command('ZRANGE', key, start, stop, 'REV');
      },
    };
  }
}

const client = new RedisConnectionPool().client;

client.get('foo').then((result) => {
  console.log('GET foo', result);
});

// This will open a second client because the last one hasn't been created yet.
client
  .get('masochist:6:last-indexed-hash')
  .then((result) => {
    console.log('GET masochist:6:last-indexed-hash', result);
  })
  .then(async () => {
    // but this chained call will use an existing client
    let result = await client.zcard('masochist:6:wiki-index');
    console.log('ZCARD masochist:6:wiki-index', result);

    // and this will too, because of the await
    result = await client.get('bar');
    console.log('GET bar', result);

    result = await client.zrevrange('masochist:6:blog-index', 10, 20);
    console.log('ZREVRANGE masochist:6:blog-index 10 20', result);

    result = await client.multi([
      ['ZREVRANGE', 'masochist:6:tag:pcre', 0, -1],
      ['ZREVRANGE', 'masochist:6:tag:skype', 0, -1],
      ['ZREVRANGE', 'masochist:6:tag:try', 0, -1],
      ['ZREVRANGE', 'masochist:6:tag:znc', 0, -1],
    ]);
    console.log('multi (4 commands):', result);
  });

// TODO move all this into StringScanner.js file
// TODO maybe copy tests from next project

function formatContext(scanner) {
  const [line, column] = scanner.location;

  return (
    `line ${line}, column ${column} of ${scanner.description}\n\n` +
    scanner.context(line, column) +
    '\n'
  );
}

function toAnchoredRegExp(regExp) {
  const {source} = regExp;

  return source.startsWith('^')
    ? regExp
    : new RegExp(`^${source}`, regExp.flags);
}

/**
 * Not the fastest thing in the world, but it makes for readable code, and we
 * don't have to deal with large responses anyway.
 */
class StringScanner {
  #description;
  #haystack;
  #index;
  #remaining;

  constructor(haystack, description) {
    this.#description = description;
    this.#haystack = haystack;
    this.#index = 0;
    this.#remaining = haystack;
  }

  /**
   * For use in error reporting.
   */
  get description() {
    return this.#description ?? 'input string';
  }

  get index() {
    return this.#index;
  }

  /**
   * Returns tuple of 1-indexed line and column number corresponding to current
   * index.
   *
   * Note that this function is typically only called during error reporting, so
   * no attempt is made to make it fast; it derives the location by scanning
   * through the string incrementing counters.
   */
  get location() {
    if (!this.#index) {
      return [1, 1];
    }

    const startOfCurrentLine = Math.max(
      this.#haystack.lastIndexOf('\n', this.#index - 1) + 1,
      this.#haystack.lastIndexOf('\r', this.#index - 1) + 1,
    );

    const column = this.#index - startOfCurrentLine + 1;

    let line = 0;
    let index = 0;

    this.#haystack.replace(/[^\r\n]*(?:\r?\n|$)/g, (match) => {
      if (match && index <= this.#index) {
        line++;
      }

      index += match.length;

      return match;
    });

    return [line, column];
  }

  get remaining() {
    return this.#remaining;
  }

  atEnd() {
    return this.#remaining.length === 0;
  }

  /**
   * Shows context at the current position in the haystack.
   *
   * Like the `location` getter, this is only intended to be used in error
   * reporting pathways, so it is not made to be fast.
   */
  context(line, column) {
    if (this.#haystack === '') {
      return '';
    }

    const lines = this.#haystack.split(/(?:\r?\n)/g);
    const start = Math.max(1, line - 2);
    const end = Math.min(lines.length, line + 3);
    const gutter = end.toString().length + 1;

    let output = '';

    for (let i = start; i <= end; i++) {
      output += i === line ? '>' : ' ';
      output += i.toString().padStart(gutter);
      output += ` | ${lines[i - 1]}\n`;

      if (i === line) {
        output += '|'.padStart(gutter + 3);
        output += ' '.repeat(column) + '^\n';
      }
    }

    return output;
  }

  expect(pattern, description) {
    const result = this.scan(pattern);

    if (result === null) {
      throw new Error(
        `Expected ${description ?? pattern} at ${formatContext(this)}`,
      );
    }

    return result;
  }

  peek(pattern) {
    return toAnchoredRegExp(pattern).test(this.#remaining);
  }

  scan(pattern) {
    const match = this.#remaining.match(toAnchoredRegExp(pattern));

    if (match) {
      const matchText = match[0];

      this.#remaining = this.#remaining.slice(matchText.length);
      this.#index += matchText.length;

      return matchText;
    }

    return null;
  }
}

class ResponseParser {
  constructor(payload) {
    this._payload = payload;
    this._scanner = new StringScanner(this._payload);
  }

  _scanCRLF() {
    this._scanner.expect(/\r\n/);
  }

  _scanInt() {
    return parseInt(this._scanner.expect(/\d+/), 10);
  }

  /**
   * Parses a Redis RESP3 response.
   *
   * Throws an error if the payload cannot be parsed (ie. it may be incomplete).
   * If that happens, the caller should retry with the full payload.
   *
   * Note that because we use recursion here, we're not expecting to handle huge
   * payloads (eg. arrays with 20k items in them etc).
   *
   * @see https://github.com/antirez/RESP3/blob/master/spec.md
   */
  parse() {
    switch (this._scanner.scan(/./)) {
      case '_': // Null
        this._scanCRLF();
        return null;
      case '$': // A bulk string.
      case '=': { // A verbatim string.
        const length = this._scanInt();
        this._scanCRLF();
        const result = this._scanner.expect(new RegExp(`.{${length}}`));
        this._scanCRLF();
        return result;
      }
      case '%': { // A map.
        const size = this._scanInt();
        this._scanCRLF();
        const result = {};
        for (let i = 0; i < size; i++) {
          const key = this.parse();
          const value = this.parse();
          result[key] = value;
        }
        return result;
      }
      case '|': { // An "attribute" dictionary (ie. metadata).
        // For now we consume/ignore this, and then recurse.
        const size = this._scanInt();
        this._scanCRLF();
        for (let i = 0; i < size; i++) {
          this.parse(); // Attribute key.
          this.parse(); // Attribute value.
        }
        return this.parse(); // The real value.
      }
      case '*': { // An array.
        const length = this._scanInt();
        this._scanCRLF();
        const result = [];
        for (let i = 0; i < length; i++) {
          result.push(this.parse());
        }
        return result;
      }
      case '~': { // A set.
        const size = this._scanInt();
        this._scanCRLF();
        const result = new Set();
        for (let i = 0; i < size; i++) {
          result.add(this.parse());
        }
        return result;
      }
      case '+': { // A simple string.
        const string = this._scanner.expect(/[^\n\r]*/);
        this._scanCRLF();
        return string;
      }
      case '-': // An error.
        const error = this._scanner.scan(/.*/).trim();
        throw new Error(`Redis error: ${error}`);
      case ':': // An integer. Technically 64-bit, so usual JS disclaimers apply.
      case '(': { // An arbitrary precision "big number" integer.
        const int = this._scanInt();
        this._scanCRLF();
        return int;
      }
      case ',': { // A double.
        // -inf, inf, \d+(\.\d+)?
        // const int = this._scanInt();
        // this._scanCRLF();
        // return int;
      }
      case '#': { // A boolean
        const kind = this._scanner.expect(/[tf]/);
        this._scanCRLF();
        return kind === 't';
      }
      default:
        if (this._scanner.atEnd()) {
          // Nothing left to parse.
          return undefined;
          // throw new Error('Unexpected end of input');
        } else {
          throw new Error('Unexpected character');
        }
    }
  }
}
